// Copyright (c) Microsoft Corporation.
// Licensed under the MIT License.
import * as tslib_1 from "tslib";
import * as assert from "assert";
import { env } from "@azure/test-utils-recorder";
import { authenticate } from "./utils/testAuthentication";
import { PollerStoppedError } from "@azure/core-lro";
describe("Secrets client - Long Running Operations - recoverDelete", function () {
    var secretPrefix = "recover" + (env.CERTIFICATE_NAME || "SecretName");
    var secretSuffix;
    var client;
    var testClient;
    var recorder;
    beforeEach(function () {
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            var authentication;
            return tslib_1.__generator(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4 /*yield*/, authenticate(this)];
                    case 1:
                        authentication = _a.sent();
                        secretSuffix = authentication.secretSuffix;
                        client = authentication.client;
                        testClient = authentication.testClient;
                        recorder = authentication.recorder;
                        return [2 /*return*/];
                }
            });
        });
    });
    afterEach(function () {
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            return tslib_1.__generator(this, function (_a) {
                recorder.stop();
                return [2 /*return*/];
            });
        });
    });
    // The tests follow
    it("can wait until a secret is recovered", function () {
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            var secretName, deletePoller, poller, secretProperties;
            return tslib_1.__generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        secretName = testClient.formatName(secretPrefix + "-" + this.test.title + "-" + secretSuffix);
                        return [4 /*yield*/, client.setSecret(secretName, "value")];
                    case 1:
                        _a.sent();
                        return [4 /*yield*/, client.beginDeleteSecret(secretName)];
                    case 2:
                        deletePoller = _a.sent();
                        return [4 /*yield*/, deletePoller.pollUntilDone()];
                    case 3:
                        _a.sent();
                        return [4 /*yield*/, client.beginRecoverDeletedSecret(secretName)];
                    case 4:
                        poller = _a.sent();
                        assert.ok(poller.getOperationState().isStarted);
                        // The pending secret properties can be obtained this way:
                        assert.equal(poller.getOperationState().result.name, secretName);
                        return [4 /*yield*/, poller.pollUntilDone()];
                    case 5:
                        secretProperties = _a.sent();
                        assert.equal(secretProperties.name, secretName);
                        assert.ok(poller.getOperationState().isCompleted);
                        // The final secret can also be obtained this way:
                        assert.equal(poller.getOperationState().result.name, secretName);
                        return [4 /*yield*/, testClient.flushSecret(secretName)];
                    case 6:
                        _a.sent();
                        return [2 /*return*/];
                }
            });
        });
    });
    it("can resume from a stopped poller", function () {
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            var secretName, deletePoller, poller, serialized, resumePoller, secretProperties;
            return tslib_1.__generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        secretName = testClient.formatName(secretPrefix + "-" + this.test.title + "-" + secretSuffix);
                        return [4 /*yield*/, client.setSecret(secretName, "value")];
                    case 1:
                        _a.sent();
                        return [4 /*yield*/, client.beginDeleteSecret(secretName)];
                    case 2:
                        deletePoller = _a.sent();
                        return [4 /*yield*/, deletePoller.pollUntilDone()];
                    case 3:
                        _a.sent();
                        return [4 /*yield*/, client.beginRecoverDeletedSecret(secretName)];
                    case 4:
                        poller = _a.sent();
                        assert.ok(poller.getOperationState().isStarted);
                        poller.pollUntilDone().catch(function (e) {
                            assert.ok(e instanceof PollerStoppedError);
                            assert.equal(e.name, "PollerStoppedError");
                            assert.equal(e.message, "This poller is already stopped");
                        });
                        return [4 /*yield*/, poller.poll()];
                    case 5:
                        _a.sent(); // Making sure it has some data
                        poller.stopPolling();
                        assert.ok(poller.isStopped());
                        assert.ok(!poller.getOperationState().isCompleted);
                        serialized = poller.toString();
                        return [4 /*yield*/, client.beginRecoverDeletedSecret(secretName, {
                                resumeFrom: serialized
                            })];
                    case 6:
                        resumePoller = _a.sent();
                        assert.ok(poller.getOperationState().isStarted);
                        return [4 /*yield*/, resumePoller.pollUntilDone()];
                    case 7:
                        secretProperties = _a.sent();
                        assert.equal(secretProperties.name, secretName);
                        assert.ok(resumePoller.getOperationState().isCompleted);
                        return [4 /*yield*/, testClient.flushSecret(secretName)];
                    case 8:
                        _a.sent();
                        return [2 /*return*/];
                }
            });
        });
    });
});
//# sourceMappingURL=lro.recover.test.js.map