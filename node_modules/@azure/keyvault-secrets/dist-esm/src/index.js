// Copyright (c) Microsoft Corporation.
// Licensed under the MIT License.
/* eslint @typescript-eslint/member-ordering: 0 */
import * as tslib_1 from "tslib";
import { isTokenCredential, signingPolicy, createPipelineFromOptions } from "@azure/core-http";
import { getTracer } from "@azure/core-tracing";
import { logger } from "./log";
import "@azure/core-paging";
import { KeyVaultClient } from "./core/keyVaultClient";
import { SDK_VERSION } from "./core/utils/constants";
import { challengeBasedAuthenticationPolicy } from "./core/challengeBasedAuthenticationPolicy";
import { DeleteSecretPoller } from "./lro/delete/poller";
import { RecoverDeletedSecretPoller } from "./lro/recover/poller";
import { parseKeyvaultIdentifier as parseKeyvaultEntityIdentifier } from "./core/utils";
export { logger };
// This is part of constructing the autogenerated client. In the future, it should not
// be required. See also: https://github.com/Azure/azure-sdk-for-js/issues/5508
var SERVICE_API_VERSION = "7.0";
/**
 * The client to interact with the KeyVault secrets functionality
 */
var SecretClient = /** @class */ (function () {
    /**
     * Creates an instance of SecretClient.
     *
     * Example usage:
     * ```ts
     * import { SecretClient } from "@azure/keyvault-secrets";
     * import { DefaultAzureCredential } from "@azure/identity";
     *
     * let url = `https://<MY KEYVAULT HERE>.vault.azure.net`;
     * let credentials = new DefaultAzureCredential();
     *
     * let client = new SecretClient(url, credentials);
     * ```
     * @param {string} endPoint the base url to the key vault.
     * @param {TokenCredential} The credential to use for API requests.
     * @param {PipelineOptions} [pipelineOptions={}] Optional. Pipeline options used to configure Key Vault API requests.
     *                                                         Omit this parameter to use the default pipeline configuration.
     * @memberof SecretClient
     */
    function SecretClient(endPoint, credential, pipelineOptions) {
        if (pipelineOptions === void 0) { pipelineOptions = {}; }
        /**
         * A self reference that bypasses private methods, for the pollers.
         */
        this.pollerClient = {
            recoverDeletedSecret: this.recoverDeletedSecret.bind(this),
            getSecret: this.getSecret.bind(this),
            deleteSecret: this.deleteSecret.bind(this),
            getDeletedSecret: this.getDeletedSecret.bind(this)
        };
        this.vaultEndpoint = endPoint;
        this.credential = credential;
        var libInfo = "azsdk-js-keyvault-secrets/" + SDK_VERSION;
        if (pipelineOptions.userAgentOptions) {
            pipelineOptions.userAgentOptions.userAgentPrefix !== undefined
                ? pipelineOptions.userAgentOptions.userAgentPrefix + " " + libInfo
                : libInfo;
        }
        else {
            pipelineOptions.userAgentOptions = {
                userAgentPrefix: libInfo
            };
        }
        var authPolicy = isTokenCredential(credential)
            ? challengeBasedAuthenticationPolicy(credential)
            : signingPolicy(credential);
        var internalPipelineOptions = tslib_1.__assign({}, pipelineOptions, {
            loggingOptions: {
                logger: logger.info,
                logPolicyOptions: {
                    allowedHeaderNames: [
                        "x-ms-keyvault-region",
                        "x-ms-keyvault-network-info",
                        "x-ms-keyvault-service-version"
                    ]
                }
            }
        });
        this.pipeline = createPipelineFromOptions(internalPipelineOptions, authPolicy);
        this.client = new KeyVaultClient(credential, SERVICE_API_VERSION, this.pipeline);
    }
    /**
     * The setSecret method adds a secret or secret version to the Azure Key Vault. If the named secret
     * already exists, Azure Key Vault creates a new version of that secret.
     * This operation requires the secrets/set permission.
     *
     * Example usage:
     * ```ts
     * let client = new SecretClient(url, credentials);
     * await client.setSecret("MySecretName", "ABC123");
     * ```
     * @summary Adds a secret in a specified key vault.
     * @param secretName The name of the secret.
     * @param value The value of the secret.
     * @param [options] The optional parameters
     */
    SecretClient.prototype.setSecret = function (secretName, value, options) {
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            var unflattenedProperties, unflattenedOptions, span, response, response;
            return tslib_1.__generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        if (!options) return [3 /*break*/, 5];
                        unflattenedProperties = {
                            enabled: options.enabled,
                            notBefore: options.notBefore,
                            expires: options.expiresOn
                        };
                        unflattenedOptions = tslib_1.__assign({}, options, { secretAttributes: unflattenedProperties });
                        delete unflattenedOptions.enabled;
                        delete unflattenedOptions.notBefore;
                        delete unflattenedOptions.expiresOn;
                        span = this.createSpan("setSecret", unflattenedOptions);
                        response = void 0;
                        _a.label = 1;
                    case 1:
                        _a.trys.push([1, , 3, 4]);
                        return [4 /*yield*/, this.client.setSecret(this.vaultEndpoint, secretName, value, this.setParentSpan(span, unflattenedOptions))];
                    case 2:
                        response = _a.sent();
                        return [3 /*break*/, 4];
                    case 3:
                        span.end();
                        return [7 /*endfinally*/];
                    case 4: return [2 /*return*/, this.getSecretFromSecretBundle(response)];
                    case 5: return [4 /*yield*/, this.client.setSecret(this.vaultEndpoint, secretName, value, options)];
                    case 6:
                        response = _a.sent();
                        return [2 /*return*/, this.getSecretFromSecretBundle(response)];
                }
            });
        });
    };
    /**
     * Deletes a secret stored in Azure Key Vault.
     * This function returns a Long Running Operation poller that allows you to wait indifinetly until the secret is deleted.
     *
     * This operation requires the secrets/delete permission.
     *
     * Example usage:
     * ```ts
     * const client = new SecretClient(url, credentials);
     * await client.setSecret("MySecretName", "ABC123");
     *
     * const deletePoller = await client.beginDeleteSecret("MySecretName");
     *
     * // Serializing the poller
     * const serialized = deletePoller.toJSON();
     *
     * // A new poller can be created with:
     * // const newPoller = await client.beginDeleteSecret("MySecretName", { resumeFrom: serialized });
     *
     * // Waiting until it's done
     * const deletedSecret = await deletePoller.pollUntilDone();
     * console.log(deletedSecret);
     * ```
     * @summary Deletes a secret from a specified key vault.
     * @param secretName The name of the secret.
     * @param [options] The optional parameters
     */
    SecretClient.prototype.beginDeleteSecret = function (name, options) {
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            var poller;
            return tslib_1.__generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        poller = new DeleteSecretPoller(tslib_1.__assign({ name: name, client: this.pollerClient }, options));
                        // This will initialize the poller's operation (the deletion of the secret).
                        return [4 /*yield*/, poller.poll()];
                    case 1:
                        // This will initialize the poller's operation (the deletion of the secret).
                        _a.sent();
                        return [2 /*return*/, poller];
                }
            });
        });
    };
    /**
     * The updateSecret method changes specified attributes of an existing stored secret. Properties that
     * are not specified in the request are left unchanged. The value of a secret itself cannot be
     * changed. This operation requires the secrets/set permission.
     *
     * Example usage:
     * ```ts
     * let secretName = "MySecretName";
     * let client = new SecretClient(url, credentials);
     * let secret = await client.getSecret(secretName);
     * await client.updateSecret(secretName, secret.version, { enabled: false });
     * ```
     * @summary Updates the attributes associated with a specified secret in a given key vault.
     * @param secretName The name of the secret.
     * @param secretVersion The version of the secret.
     * @param [options] The optional parameters
     */
    SecretClient.prototype.updateSecretProperties = function (secretName, secretVersion, options) {
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            var unflattenedProperties, unflattenedOptions, span, response, response;
            return tslib_1.__generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        if (!options) return [3 /*break*/, 5];
                        unflattenedProperties = {
                            enabled: options.enabled,
                            notBefore: options.notBefore,
                            expires: options.expiresOn
                        };
                        unflattenedOptions = tslib_1.__assign({}, options, { secretAttributes: unflattenedProperties });
                        delete unflattenedOptions.enabled;
                        delete unflattenedOptions.notBefore;
                        delete unflattenedOptions.expiresOn;
                        span = this.createSpan("updateSecretProperties", unflattenedOptions);
                        response = void 0;
                        _a.label = 1;
                    case 1:
                        _a.trys.push([1, , 3, 4]);
                        return [4 /*yield*/, this.client.updateSecret(this.vaultEndpoint, secretName, secretVersion, this.setParentSpan(span, unflattenedOptions))];
                    case 2:
                        response = _a.sent();
                        return [3 /*break*/, 4];
                    case 3:
                        span.end();
                        return [7 /*endfinally*/];
                    case 4: return [2 /*return*/, this.getSecretFromSecretBundle(response).properties];
                    case 5: return [4 /*yield*/, this.client.updateSecret(this.vaultEndpoint, secretName, secretVersion, options)];
                    case 6:
                        response = _a.sent();
                        return [2 /*return*/, this.getSecretFromSecretBundle(response).properties];
                }
            });
        });
    };
    /**
     * The getSecret method is applicable to any secret stored in Azure Key Vault. This operation requires
     * the secrets/get permission.
     *
     * Example usage:
     * ```ts
     * let client = new SecretClient(url, credentials);
     * let secret = await client.getSecret("MySecretName");
     * ```
     * @summary Get a specified secret from a given key vault.
     * @param secretName The name of the secret.
     * @param [options] The optional parameters
     */
    SecretClient.prototype.getSecret = function (secretName, options) {
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            var span, requestOptions, response;
            return tslib_1.__generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        span = this.createSpan("getSecret", options);
                        requestOptions = this.setParentSpan(span, options);
                        _a.label = 1;
                    case 1:
                        _a.trys.push([1, , 3, 4]);
                        return [4 /*yield*/, this.client.getSecret(this.vaultEndpoint, secretName, options && options.version ? options.version : "", requestOptions)];
                    case 2:
                        response = _a.sent();
                        return [3 /*break*/, 4];
                    case 3:
                        span.end();
                        return [7 /*endfinally*/];
                    case 4: return [2 /*return*/, this.getSecretFromSecretBundle(response)];
                }
            });
        });
    };
    /**
     * The getDeletedSecret method returns the specified deleted secret along with its attributes.
     * This operation requires the secrets/get permission.
     *
     * Example usage:
     * ```ts
     * let client = new SecretClient(url, credentials);
     * await client.getDeletedSecret("MyDeletedSecret");
     * ```
     * @summary Gets the specified deleted secret.
     * @param secretName The name of the secret.
     * @param [options] The optional parameters
     */
    SecretClient.prototype.getDeletedSecret = function (secretName, options) {
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            var span, response;
            return tslib_1.__generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        span = this.createSpan("getDeletedSecret", options);
                        _a.label = 1;
                    case 1:
                        _a.trys.push([1, , 3, 4]);
                        return [4 /*yield*/, this.client.getDeletedSecret(this.vaultEndpoint, secretName, this.setParentSpan(span, options))];
                    case 2:
                        response = _a.sent();
                        return [3 /*break*/, 4];
                    case 3:
                        span.end();
                        return [7 /*endfinally*/];
                    case 4: return [2 /*return*/, this.getSecretFromSecretBundle(response)];
                }
            });
        });
    };
    /**
     * The purge deleted secret operation removes the secret permanently, without the possibility of
     * recovery. This operation can only be enabled on a soft-delete enabled vault. This operation
     * requires the secrets/purge permission.
     *
     * Example usage:
     * ```ts
     * const client = new SecretClient(url, credentials);
     * const deletePoller = await client.beginDeleteSecret("MySecretName");
     * await deletePoller.pollUntilDone();
     * await client.purgeDeletedSecret("MySecretName");
     * ```
     * @summary Permanently deletes the specified secret.
     * @param secretName The name of the secret.
     * @param [options] The optional parameters
     */
    SecretClient.prototype.purgeDeletedSecret = function (secretName, options) {
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            var span;
            return tslib_1.__generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        span = this.createSpan("purgeDeletedSecret", options);
                        _a.label = 1;
                    case 1:
                        _a.trys.push([1, , 3, 4]);
                        return [4 /*yield*/, this.client.purgeDeletedSecret(this.vaultEndpoint, secretName, this.setParentSpan(span, options))];
                    case 2:
                        _a.sent();
                        return [3 /*break*/, 4];
                    case 3:
                        span.end();
                        return [7 /*endfinally*/];
                    case 4: return [2 /*return*/];
                }
            });
        });
    };
    /**
     * Recovers the deleted secret in the specified vault.
     * This function returns a Long Running Operation poller that allows you to wait indifinetly until the secret is recovered.
     *
     * This operation requires the secrets/recover permission.
     *
     * Example usage:
     * ```ts
     * const client = new SecretClient(url, credentials);
     * await client.setSecret("MySecretName", "ABC123");
     *
     * const deletePoller = await client.beginDeleteSecret("MySecretName");
     * await deletePoller.pollUntilDone();
     *
     * const recoverPoller = await client.recoverDeletedSecret("MySecretName");
     *
     * // Serializing the poller
     * const serialized = recoverPoller.toJSON();
     *
     * // A new poller can be created with:
     * // const newPoller = await client.beginRecoverDeletedSecret("MySecretName", { resumeFrom: serialized });
     *
     * // Waiting until it's done
     * const deletedSecret = await recoverPoller.pollUntilDone();
     * console.log(deletedSecret);
     * ```
     * @summary Recovers the deleted secret to the latest version.
     * @param secretName The name of the deleted secret.
     * @param [options] The optional parameters
     */
    SecretClient.prototype.beginRecoverDeletedSecret = function (name, options) {
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            var poller;
            return tslib_1.__generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        poller = new RecoverDeletedSecretPoller(tslib_1.__assign({ name: name, client: this.pollerClient }, options));
                        // This will initialize the poller's operation (the recovery of the deleted secret).
                        return [4 /*yield*/, poller.poll()];
                    case 1:
                        // This will initialize the poller's operation (the recovery of the deleted secret).
                        _a.sent();
                        return [2 /*return*/, poller];
                }
            });
        });
    };
    /**
     * Requests that a backup of the specified secret be downloaded to the client. All versions of the
     * secret will be downloaded. This operation requires the secrets/backup permission.
     *
     * Example usage:
     * ```ts
     * let client = new SecretClient(url, credentials);
     * let backupResult = await client.backupSecret("MySecretName");
     * ```
     * @summary Backs up the specified secret.
     * @param secretName The name of the secret.
     * @param [options] The optional parameters
     */
    SecretClient.prototype.backupSecret = function (secretName, options) {
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            var span, response;
            return tslib_1.__generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        span = this.createSpan("backupSecret", options);
                        _a.label = 1;
                    case 1:
                        _a.trys.push([1, , 3, 4]);
                        return [4 /*yield*/, this.client.backupSecret(this.vaultEndpoint, secretName, this.setParentSpan(span, options))];
                    case 2:
                        response = _a.sent();
                        return [3 /*break*/, 4];
                    case 3:
                        span.end();
                        return [7 /*endfinally*/];
                    case 4: return [2 /*return*/, response.value];
                }
            });
        });
    };
    /**
     * Restores a backed up secret, and all its versions, to a vault. This operation requires the
     * secrets/restore permission.
     *
     * Example usage:
     * ```ts
     * let client = new SecretClient(url, credentials);
     * let mySecretBundle = await client.backupSecret("MySecretName");
     * // ...
     * await client.restoreSecretBackup(mySecretBundle);
     * ```
     * @summary Restores a backed up secret to a vault.
     * @param secretBundleBackup The backup blob associated with a secret bundle.
     * @param [options] The optional parameters
     */
    SecretClient.prototype.restoreSecretBackup = function (secretBundleBackup, options) {
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            var span, response;
            return tslib_1.__generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        span = this.createSpan("restoreSecretBackup", options);
                        _a.label = 1;
                    case 1:
                        _a.trys.push([1, , 3, 4]);
                        return [4 /*yield*/, this.client.restoreSecret(this.vaultEndpoint, secretBundleBackup, this.setParentSpan(span, options))];
                    case 2:
                        response = _a.sent();
                        return [3 /*break*/, 4];
                    case 3:
                        span.end();
                        return [7 /*endfinally*/];
                    case 4: return [2 /*return*/, this.getSecretFromSecretBundle(response).properties];
                }
            });
        });
    };
    SecretClient.prototype.deleteSecret = function (secretName, options) {
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            var span, response;
            return tslib_1.__generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        span = this.createSpan("deleteSecret", options);
                        _a.label = 1;
                    case 1:
                        _a.trys.push([1, , 3, 4]);
                        return [4 /*yield*/, this.client.deleteSecret(this.vaultEndpoint, secretName, this.setParentSpan(span, options))];
                    case 2:
                        response = _a.sent();
                        return [3 /*break*/, 4];
                    case 3:
                        span.end();
                        return [7 /*endfinally*/];
                    case 4: return [2 /*return*/, this.getSecretFromSecretBundle(response)];
                }
            });
        });
    };
    SecretClient.prototype.recoverDeletedSecret = function (secretName, options) {
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            var span, properties, response;
            return tslib_1.__generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        span = this.createSpan("recoverDeletedSecret", options);
                        _a.label = 1;
                    case 1:
                        _a.trys.push([1, , 3, 4]);
                        return [4 /*yield*/, this.client.recoverDeletedSecret(this.vaultEndpoint, secretName, this.setParentSpan(span, options))];
                    case 2:
                        response = _a.sent();
                        properties = this.getSecretFromSecretBundle(response).properties;
                        return [3 /*break*/, 4];
                    case 3:
                        span.end();
                        return [7 /*endfinally*/];
                    case 4: return [2 /*return*/, properties];
                }
            });
        });
    };
    SecretClient.prototype.listPropertiesOfSecretVersionsPage = function (secretName, continuationState, options) {
        return tslib_1.__asyncGenerator(this, arguments, function listPropertiesOfSecretVersionsPage_1() {
            var optionsComplete, currentSetResponse, currentSetResponse;
            var _this = this;
            return tslib_1.__generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        if (!(continuationState.continuationToken == null)) return [3 /*break*/, 4];
                        optionsComplete = tslib_1.__assign({ maxresults: continuationState.maxPageSize }, options);
                        return [4 /*yield*/, tslib_1.__await(this.client.getSecretVersions(this.vaultEndpoint, secretName, optionsComplete))];
                    case 1:
                        currentSetResponse = _a.sent();
                        continuationState.continuationToken = currentSetResponse.nextLink;
                        if (!currentSetResponse.value) return [3 /*break*/, 4];
                        return [4 /*yield*/, tslib_1.__await(currentSetResponse.value.map(function (bundle) { return _this.getSecretFromSecretBundle(bundle).properties; }))];
                    case 2: return [4 /*yield*/, _a.sent()];
                    case 3:
                        _a.sent();
                        _a.label = 4;
                    case 4:
                        if (!continuationState.continuationToken) return [3 /*break*/, 10];
                        return [4 /*yield*/, tslib_1.__await(this.client.getSecretVersions(continuationState.continuationToken, secretName, options))];
                    case 5:
                        currentSetResponse = _a.sent();
                        continuationState.continuationToken = currentSetResponse.nextLink;
                        if (!currentSetResponse.value) return [3 /*break*/, 8];
                        return [4 /*yield*/, tslib_1.__await(currentSetResponse.value.map(function (bundle) { return _this.getSecretFromSecretBundle(bundle).properties; }))];
                    case 6: return [4 /*yield*/, _a.sent()];
                    case 7:
                        _a.sent();
                        return [3 /*break*/, 9];
                    case 8: return [3 /*break*/, 10];
                    case 9: return [3 /*break*/, 4];
                    case 10: return [2 /*return*/];
                }
            });
        });
    };
    SecretClient.prototype.listPropertiesOfSecretVersionsAll = function (secretName, options) {
        return tslib_1.__asyncGenerator(this, arguments, function listPropertiesOfSecretVersionsAll_1() {
            var f, _a, _b, page, _i, page_1, item, e_1_1;
            var e_1, _c;
            return tslib_1.__generator(this, function (_d) {
                switch (_d.label) {
                    case 0:
                        f = {};
                        _d.label = 1;
                    case 1:
                        _d.trys.push([1, 10, 11, 16]);
                        _a = tslib_1.__asyncValues(this.listPropertiesOfSecretVersionsPage(secretName, f, options));
                        _d.label = 2;
                    case 2: return [4 /*yield*/, tslib_1.__await(_a.next())];
                    case 3:
                        if (!(_b = _d.sent(), !_b.done)) return [3 /*break*/, 9];
                        page = _b.value;
                        _i = 0, page_1 = page;
                        _d.label = 4;
                    case 4:
                        if (!(_i < page_1.length)) return [3 /*break*/, 8];
                        item = page_1[_i];
                        return [4 /*yield*/, tslib_1.__await(item)];
                    case 5: return [4 /*yield*/, _d.sent()];
                    case 6:
                        _d.sent();
                        _d.label = 7;
                    case 7:
                        _i++;
                        return [3 /*break*/, 4];
                    case 8: return [3 /*break*/, 2];
                    case 9: return [3 /*break*/, 16];
                    case 10:
                        e_1_1 = _d.sent();
                        e_1 = { error: e_1_1 };
                        return [3 /*break*/, 16];
                    case 11:
                        _d.trys.push([11, , 14, 15]);
                        if (!(_b && !_b.done && (_c = _a.return))) return [3 /*break*/, 13];
                        return [4 /*yield*/, tslib_1.__await(_c.call(_a))];
                    case 12:
                        _d.sent();
                        _d.label = 13;
                    case 13: return [3 /*break*/, 15];
                    case 14:
                        if (e_1) throw e_1.error;
                        return [7 /*endfinally*/];
                    case 15: return [7 /*endfinally*/];
                    case 16: return [2 /*return*/];
                }
            });
        });
    };
    /**
     * Iterates all versions of the given secret in the vault. The full secret identifier and attributes are provided
     * in the response. No values are returned for the secrets. This operations requires the secrets/list permission.
     *
     * Example usage:
     * ```ts
     * let client = new SecretClient(url, credentials);
     * for await (const secretAttr of client.listPropertiesOfSecretVersions("MySecretName")) {
     *   const secret = await client.getSecret(secretAttr.name);
     *   console.log("secret version: ", secret);
     * }
     * ```
     * @param secretName Name of the secret to fetch versions for
     * @param [options] The optional parameters
     */
    SecretClient.prototype.listPropertiesOfSecretVersions = function (secretName, options) {
        var _a;
        var _this = this;
        var span = this.createSpan("listPropertiesOfSecretVersions", options);
        var updatedOptions = tslib_1.__assign({}, options, this.setParentSpan(span, options));
        var iter = this.listPropertiesOfSecretVersionsAll(secretName, updatedOptions);
        span.end();
        return _a = {
                next: function () {
                    return iter.next();
                }
            },
            _a[Symbol.asyncIterator] = function () {
                return this;
            },
            _a.byPage = function (settings) {
                if (settings === void 0) { settings = {}; }
                return _this.listPropertiesOfSecretVersionsPage(secretName, settings, updatedOptions);
            },
            _a;
    };
    SecretClient.prototype.listPropertiesOfSecretsPage = function (continuationState, options) {
        return tslib_1.__asyncGenerator(this, arguments, function listPropertiesOfSecretsPage_1() {
            var optionsComplete, currentSetResponse, currentSetResponse;
            var _this = this;
            return tslib_1.__generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        if (!(continuationState.continuationToken == null)) return [3 /*break*/, 4];
                        optionsComplete = tslib_1.__assign({ maxresults: continuationState.maxPageSize }, options);
                        return [4 /*yield*/, tslib_1.__await(this.client.getSecrets(this.vaultEndpoint, optionsComplete))];
                    case 1:
                        currentSetResponse = _a.sent();
                        continuationState.continuationToken = currentSetResponse.nextLink;
                        if (!currentSetResponse.value) return [3 /*break*/, 4];
                        return [4 /*yield*/, tslib_1.__await(currentSetResponse.value.map(function (bundle) { return _this.getSecretFromSecretBundle(bundle).properties; }))];
                    case 2: return [4 /*yield*/, _a.sent()];
                    case 3:
                        _a.sent();
                        _a.label = 4;
                    case 4:
                        if (!continuationState.continuationToken) return [3 /*break*/, 10];
                        return [4 /*yield*/, tslib_1.__await(this.client.getSecrets(continuationState.continuationToken, options))];
                    case 5:
                        currentSetResponse = _a.sent();
                        continuationState.continuationToken = currentSetResponse.nextLink;
                        if (!currentSetResponse.value) return [3 /*break*/, 8];
                        return [4 /*yield*/, tslib_1.__await(currentSetResponse.value.map(function (bundle) { return _this.getSecretFromSecretBundle(bundle).properties; }))];
                    case 6: return [4 /*yield*/, _a.sent()];
                    case 7:
                        _a.sent();
                        return [3 /*break*/, 9];
                    case 8: return [3 /*break*/, 10];
                    case 9: return [3 /*break*/, 4];
                    case 10: return [2 /*return*/];
                }
            });
        });
    };
    SecretClient.prototype.listPropertiesOfSecretsAll = function (options) {
        return tslib_1.__asyncGenerator(this, arguments, function listPropertiesOfSecretsAll_1() {
            var f, _a, _b, page, _i, page_2, item, e_2_1;
            var e_2, _c;
            return tslib_1.__generator(this, function (_d) {
                switch (_d.label) {
                    case 0:
                        f = {};
                        _d.label = 1;
                    case 1:
                        _d.trys.push([1, 10, 11, 16]);
                        _a = tslib_1.__asyncValues(this.listPropertiesOfSecretsPage(f, options));
                        _d.label = 2;
                    case 2: return [4 /*yield*/, tslib_1.__await(_a.next())];
                    case 3:
                        if (!(_b = _d.sent(), !_b.done)) return [3 /*break*/, 9];
                        page = _b.value;
                        _i = 0, page_2 = page;
                        _d.label = 4;
                    case 4:
                        if (!(_i < page_2.length)) return [3 /*break*/, 8];
                        item = page_2[_i];
                        return [4 /*yield*/, tslib_1.__await(item)];
                    case 5: return [4 /*yield*/, _d.sent()];
                    case 6:
                        _d.sent();
                        _d.label = 7;
                    case 7:
                        _i++;
                        return [3 /*break*/, 4];
                    case 8: return [3 /*break*/, 2];
                    case 9: return [3 /*break*/, 16];
                    case 10:
                        e_2_1 = _d.sent();
                        e_2 = { error: e_2_1 };
                        return [3 /*break*/, 16];
                    case 11:
                        _d.trys.push([11, , 14, 15]);
                        if (!(_b && !_b.done && (_c = _a.return))) return [3 /*break*/, 13];
                        return [4 /*yield*/, tslib_1.__await(_c.call(_a))];
                    case 12:
                        _d.sent();
                        _d.label = 13;
                    case 13: return [3 /*break*/, 15];
                    case 14:
                        if (e_2) throw e_2.error;
                        return [7 /*endfinally*/];
                    case 15: return [7 /*endfinally*/];
                    case 16: return [2 /*return*/];
                }
            });
        });
    };
    /**
     * Iterates the latest version of all secrets in the vault.  The full secret identifier and attributes are provided
     * in the response. No values are returned for the secrets. This operations requires the secrets/list permission.
     *
     * Example usage:
     * ```ts
     * let client = new SecretClient(url, credentials);
     * for await (const secretAttr of client.listPropertiesOfSecrets()) {
     *   const secret = await client.getSecret(secretAttr.name);
     *   console.log("secret: ", secret);
     * }
     * ```
     * @summary List all secrets in the vault
     * @param [options] The optional parameters
     */
    SecretClient.prototype.listPropertiesOfSecrets = function (options) {
        var _a;
        var _this = this;
        var span = this.createSpan("listPropertiesOfSecrets", options);
        var updatedOptions = tslib_1.__assign({}, options, this.setParentSpan(span, options));
        var iter = this.listPropertiesOfSecretsAll(updatedOptions);
        span.end();
        return _a = {
                next: function () {
                    return iter.next();
                }
            },
            _a[Symbol.asyncIterator] = function () {
                return this;
            },
            _a.byPage = function (settings) {
                if (settings === void 0) { settings = {}; }
                return _this.listPropertiesOfSecretsPage(settings, updatedOptions);
            },
            _a;
    };
    SecretClient.prototype.listDeletedSecretsPage = function (continuationState, options) {
        return tslib_1.__asyncGenerator(this, arguments, function listDeletedSecretsPage_1() {
            var optionsComplete, currentSetResponse, currentSetResponse;
            var _this = this;
            return tslib_1.__generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        if (!(continuationState.continuationToken == null)) return [3 /*break*/, 4];
                        optionsComplete = tslib_1.__assign({ maxresults: continuationState.maxPageSize }, options);
                        return [4 /*yield*/, tslib_1.__await(this.client.getDeletedSecrets(this.vaultEndpoint, optionsComplete))];
                    case 1:
                        currentSetResponse = _a.sent();
                        continuationState.continuationToken = currentSetResponse.nextLink;
                        if (!currentSetResponse.value) return [3 /*break*/, 4];
                        return [4 /*yield*/, tslib_1.__await(currentSetResponse.value.map(function (bundle) { return _this.getSecretFromSecretBundle(bundle); }))];
                    case 2: return [4 /*yield*/, _a.sent()];
                    case 3:
                        _a.sent();
                        _a.label = 4;
                    case 4:
                        if (!continuationState.continuationToken) return [3 /*break*/, 10];
                        return [4 /*yield*/, tslib_1.__await(this.client.getDeletedSecrets(continuationState.continuationToken, options))];
                    case 5:
                        currentSetResponse = _a.sent();
                        continuationState.continuationToken = currentSetResponse.nextLink;
                        if (!currentSetResponse.value) return [3 /*break*/, 8];
                        return [4 /*yield*/, tslib_1.__await(currentSetResponse.value.map(function (bundle) { return _this.getSecretFromSecretBundle(bundle); }))];
                    case 6: return [4 /*yield*/, _a.sent()];
                    case 7:
                        _a.sent();
                        return [3 /*break*/, 9];
                    case 8: return [3 /*break*/, 10];
                    case 9: return [3 /*break*/, 4];
                    case 10: return [2 /*return*/];
                }
            });
        });
    };
    SecretClient.prototype.listDeletedSecretsAll = function (options) {
        return tslib_1.__asyncGenerator(this, arguments, function listDeletedSecretsAll_1() {
            var f, _a, _b, page, _i, page_3, item, e_3_1;
            var e_3, _c;
            return tslib_1.__generator(this, function (_d) {
                switch (_d.label) {
                    case 0:
                        f = {};
                        _d.label = 1;
                    case 1:
                        _d.trys.push([1, 10, 11, 16]);
                        _a = tslib_1.__asyncValues(this.listDeletedSecretsPage(f, options));
                        _d.label = 2;
                    case 2: return [4 /*yield*/, tslib_1.__await(_a.next())];
                    case 3:
                        if (!(_b = _d.sent(), !_b.done)) return [3 /*break*/, 9];
                        page = _b.value;
                        _i = 0, page_3 = page;
                        _d.label = 4;
                    case 4:
                        if (!(_i < page_3.length)) return [3 /*break*/, 8];
                        item = page_3[_i];
                        return [4 /*yield*/, tslib_1.__await(item)];
                    case 5: return [4 /*yield*/, _d.sent()];
                    case 6:
                        _d.sent();
                        _d.label = 7;
                    case 7:
                        _i++;
                        return [3 /*break*/, 4];
                    case 8: return [3 /*break*/, 2];
                    case 9: return [3 /*break*/, 16];
                    case 10:
                        e_3_1 = _d.sent();
                        e_3 = { error: e_3_1 };
                        return [3 /*break*/, 16];
                    case 11:
                        _d.trys.push([11, , 14, 15]);
                        if (!(_b && !_b.done && (_c = _a.return))) return [3 /*break*/, 13];
                        return [4 /*yield*/, tslib_1.__await(_c.call(_a))];
                    case 12:
                        _d.sent();
                        _d.label = 13;
                    case 13: return [3 /*break*/, 15];
                    case 14:
                        if (e_3) throw e_3.error;
                        return [7 /*endfinally*/];
                    case 15: return [7 /*endfinally*/];
                    case 16: return [2 /*return*/];
                }
            });
        });
    };
    /**
     * Iterates the deleted secrets in the vault.  The full secret identifier and attributes are provided
     * in the response. No values are returned for the secrets. This operations requires the secrets/list permission.
     *
     * Example usage:
     * ```ts
     * let client = new SecretClient(url, credentials);
     * for await (const secretAttr of client.listDeletedSecrets()) {
     *   const deletedSecret = await client.getSecret(secretAttr.name);
     *   console.log("deleted secret: ", deletedSecret);
     * }
     * ```
     * @summary List all secrets in the vault
     * @param [options] The optional parameters
     */
    SecretClient.prototype.listDeletedSecrets = function (options) {
        var _a;
        var _this = this;
        var span = this.createSpan("listDeletedSecrets", options);
        var updatedOptions = tslib_1.__assign({}, options, this.setParentSpan(span, options));
        var iter = this.listDeletedSecretsAll(updatedOptions);
        span.end();
        return _a = {
                next: function () {
                    return iter.next();
                }
            },
            _a[Symbol.asyncIterator] = function () {
                return this;
            },
            _a.byPage = function (settings) {
                if (settings === void 0) { settings = {}; }
                return _this.listDeletedSecretsPage(settings, updatedOptions);
            },
            _a;
    };
    SecretClient.prototype.getSecretFromSecretBundle = function (bundle) {
        var secretBundle = bundle;
        var deletedSecretBundle = bundle;
        var parsedId = parseKeyvaultEntityIdentifier("secrets", secretBundle.id);
        var attributes = secretBundle.attributes;
        delete secretBundle.attributes;
        var resultObject = {
            value: secretBundle.value,
            name: parsedId.name,
            properties: tslib_1.__assign({ vaultEndpoint: parsedId.vaultUrl, expiresOn: attributes.expires, createdOn: attributes.created, updatedOn: attributes.updated }, secretBundle, parsedId, attributes)
        };
        if (deletedSecretBundle.deletedDate) {
            resultObject.properties.deletedOn = deletedSecretBundle.deletedDate;
            delete resultObject.properties.deletedDate;
        }
        if (attributes) {
            if (attributes.vaultUrl) {
                delete resultObject.properties.vaultUrl;
            }
            if (attributes.expires) {
                delete resultObject.properties.expires;
            }
            if (attributes.created) {
                delete resultObject.properties.created;
            }
            if (attributes.updated) {
                delete resultObject.properties.updated;
            }
        }
        return resultObject;
    };
    /**
     * Creates a span using the tracer that was set by the user
     * @param methodName The name of the method for which the span is being created.
     * @param requestOptions The options for the underlying http request.
     */
    SecretClient.prototype.createSpan = function (methodName, requestOptions) {
        var tracer = getTracer();
        return tracer.startSpan(methodName, requestOptions && requestOptions.spanOptions);
    };
    /**
     * Returns updated HTTP options with the given span as the parent of future spans,
     * if applicable.
     * @param span The span for the current operation
     * @param options The options for the underlying http request
     */
    SecretClient.prototype.setParentSpan = function (span, options) {
        if (options === void 0) { options = {}; }
        if (span.isRecordingEvents()) {
            return tslib_1.__assign({}, options, { spanOptions: tslib_1.__assign({}, options.spanOptions, { parent: span }) });
        }
        else {
            return options;
        }
    };
    return SecretClient;
}());
export { SecretClient };
//# sourceMappingURL=index.js.map