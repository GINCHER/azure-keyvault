import * as coreHttp from '@azure/core-http';
import { PagedAsyncIterableIterator } from '@azure/core-paging';
import { PageSettings } from '@azure/core-paging';
import { PipelineOptions } from '@azure/core-http';
import { PollerLike } from '@azure/core-lro';
import { PollOperationState } from '@azure/core-lro';
import { RequestOptionsBase } from '@azure/core-http';
import { ServiceClientOptions } from '@azure/core-http';
import { TokenCredential } from '@azure/core-http';

/**
 * @interface
 * An interface representing optional parameters for the backupSecret method
 */
export declare interface BackupSecretOptions extends coreHttp.RequestOptionsBase {
}

/**
 * @interface
 * An interface representing a deleted secret.
 */
export declare interface DeletedSecret {
    /**
     * @member {SecretProperties} [properties] The properties of the secret
     */
    properties: SecretProperties & {
        /**
         * @member {string} [recoveryId] The url of the recovery object, used to
         * identify and recover the deleted secret.
         */
        recoveryId?: string;
        /**
         * @member {Date} [scheduledPurgeDate] The time when the secret is scheduled
         * to be purged, in UTC
         * **NOTE: This property will not be serialized. It can only be populated by
         * the server.**
         */
        scheduledPurgeDate?: Date;
        /**
         * @member {Date} [deletedOn] The time when the secret was deleted, in UTC
         * **NOTE: This property will not be serialized. It can only be populated by
         * the server.**
         */
        deletedOn?: Date;
    };
    /**
     * @member {string} [value] The secret value.
     */
    value?: string;
    /**
     * @member {string} [name] The name of key/secret/certificate.
     */
    name: string;
}

/**
 * @interface
 * An interface representing the state of a delete secret's poll operation
 */
export declare interface DeleteSecretPollOperationState extends PollOperationState<DeletedSecret> {
    name: string;
    requestOptions?: RequestOptionsBase;
    client: SecretClientInterface;
}

/**
 * Defines values for DeletionRecoveryLevel.
 * Possible values include: 'Purgeable', 'Recoverable+Purgeable', 'Recoverable',
 * 'Recoverable+ProtectedSubscription'
 * @readonly
 * @enum {string}
 */
export declare type DeletionRecoveryLevel = "Purgeable" | "Recoverable+Purgeable" | "Recoverable" | "Recoverable+ProtectedSubscription";

/**
 * @interface
 * An interface representing optional parameters for the getDeletedSecret method
 */
export declare interface GetDeletedSecretOptions extends coreHttp.RequestOptionsBase {
}

/**
 * @interface
 * An interface representing the optional parameters that can be passed to getSecret.
 */
export declare interface GetSecretOptions extends coreHttp.RequestOptionsBase {
    /**
     * @member {string} [version] The version of the secret to retrieve.  If not
     * specified the latest version of the secret will be retrieved.
     */
    version?: string;
}

/**
 * @interface
 * An interface representing the complete secret.
 */
export declare interface KeyVaultSecret {
    /**
     * @member {SecretProperties} [properties] The properties of the secret
     */
    properties: SecretProperties;
    /**
     * @member {string} [value] The secret value.
     */
    value?: string;
    /**
     * @member {string} [name] The name of key/secret/certificate.
     */
    name: string;
}

/**
 * @interface
 * An interface representing optional parameters for SecretClient paged operations.
 */
export declare interface ListOperationOptions extends coreHttp.RequestOptionsBase {
}

/**
 * The @azure/logger configuration for this package.
 */
export declare const logger: import("@azure/logger").AzureLogger;
export { PagedAsyncIterableIterator }
export { PageSettings }

export declare interface ParsedKeyVaultEntityIdentifier {
    /**
     * @member {string} [vaultUrl] The vault URI.
     */
    vaultUrl: string;
    /**
     * @member {string} [version] The version of key/secret/certificate. May be undefined.
     */
    version?: string;
    /**
     * @member {string} [name] The name of key/secret/certificate.
     */
    name: string;
}
export { PipelineOptions }
export { PollerLike }
export { PollOperationState }

/**
 * Interface of proxy policy options.
 *
 * @export
 * @interface ProxyOptions
 */
export declare interface ProxyOptions {
    proxySettings?: string;
}

/**
 * @interface
 * An interface representing optional parameters for the purgeDeletedSecret method
 */
export declare interface PurgeDeletedSecretOptions extends coreHttp.RequestOptionsBase {
}

/**
 * @interface
 * An interface representing the state of a delete secret's poll operation
 */
export declare interface RecoverDeletedSecretPollOperationState extends PollOperationState<SecretProperties> {
    name: string;
    requestOptions?: RequestOptionsBase;
    client: SecretClientInterface;
}

/**
 * @interface
 * An interface representing optional parameters for the restoreSecretBackup method
 */
export declare interface RestoreSecretBackupOptions extends coreHttp.RequestOptionsBase {
}

/**
 * Retry options interface.
 *
 * @export
 * @interface RetryOptions
 */
export declare interface RetryOptions {
    /**
     * Optional. Max try number of attempts, default is 3.
     * A value of 1 means 1 try and no retries.
     * A value smaller than 1 means default retry number of attempts.
     *
     * @type {number}
     * @memberof RetryOptions
     */
    readonly retryCount?: number;
    /**
     * Optional. Specifies the amount of delay to use before retrying an operation (default is 30s or 30 * 1000ms).
     * The delay increases exponentially with each retry up to a maximum specified by maxRetryDelayInMs.
     *
     * @type {number}
     * @memberof RetryOptions
     */
    readonly retryIntervalInMS?: number;
    /**
     * Optional. Specifies the maximum delay allowed before retrying an operation (default is 90s or 90 * 1000ms).
     *
     * @type {number}
     * @memberof RetryOptions
     */
    readonly maxRetryDelayInMs?: number;
}

/**
 * The client to interact with the KeyVault secrets functionality
 */
export declare class SecretClient {
    /**
     * The base URL to the vault
     */
    readonly vaultEndpoint: string;
    /**
     * The options to create the connection to the service
     */
    readonly pipeline: ServiceClientOptions;
    /**
     * The authentication credentials
     */
    protected readonly credential: TokenCredential;
    private readonly client;
    /**
     * A self reference that bypasses private methods, for the pollers.
     */
    private readonly pollerClient;
    /**
     * Creates an instance of SecretClient.
     *
     * Example usage:
     * ```ts
     * import { SecretClient } from "@azure/keyvault-secrets";
     * import { DefaultAzureCredential } from "@azure/identity";
     *
     * let url = `https://<MY KEYVAULT HERE>.vault.azure.net`;
     * let credentials = new DefaultAzureCredential();
     *
     * let client = new SecretClient(url, credentials);
     * ```
     * @param {string} endPoint the base url to the key vault.
     * @param {TokenCredential} The credential to use for API requests.
     * @param {PipelineOptions} [pipelineOptions={}] Optional. Pipeline options used to configure Key Vault API requests.
     *                                                         Omit this parameter to use the default pipeline configuration.
     * @memberof SecretClient
     */
    constructor(endPoint: string, credential: TokenCredential, pipelineOptions?: PipelineOptions);
    /**
     * The setSecret method adds a secret or secret version to the Azure Key Vault. If the named secret
     * already exists, Azure Key Vault creates a new version of that secret.
     * This operation requires the secrets/set permission.
     *
     * Example usage:
     * ```ts
     * let client = new SecretClient(url, credentials);
     * await client.setSecret("MySecretName", "ABC123");
     * ```
     * @summary Adds a secret in a specified key vault.
     * @param secretName The name of the secret.
     * @param value The value of the secret.
     * @param [options] The optional parameters
     */
    setSecret(secretName: string, value: string, options?: SetSecretOptions): Promise<KeyVaultSecret>;
    /**
     * Deletes a secret stored in Azure Key Vault.
     * This function returns a Long Running Operation poller that allows you to wait indifinetly until the secret is deleted.
     *
     * This operation requires the secrets/delete permission.
     *
     * Example usage:
     * ```ts
     * const client = new SecretClient(url, credentials);
     * await client.setSecret("MySecretName", "ABC123");
     *
     * const deletePoller = await client.beginDeleteSecret("MySecretName");
     *
     * // Serializing the poller
     * const serialized = deletePoller.toJSON();
     *
     * // A new poller can be created with:
     * // const newPoller = await client.beginDeleteSecret("MySecretName", { resumeFrom: serialized });
     *
     * // Waiting until it's done
     * const deletedSecret = await deletePoller.pollUntilDone();
     * console.log(deletedSecret);
     * ```
     * @summary Deletes a secret from a specified key vault.
     * @param secretName The name of the secret.
     * @param [options] The optional parameters
     */
    beginDeleteSecret(name: string, options?: SecretPollerOptions): Promise<PollerLike<PollOperationState<DeletedSecret>, DeletedSecret>>;
    /**
     * The updateSecret method changes specified attributes of an existing stored secret. Properties that
     * are not specified in the request are left unchanged. The value of a secret itself cannot be
     * changed. This operation requires the secrets/set permission.
     *
     * Example usage:
     * ```ts
     * let secretName = "MySecretName";
     * let client = new SecretClient(url, credentials);
     * let secret = await client.getSecret(secretName);
     * await client.updateSecret(secretName, secret.version, { enabled: false });
     * ```
     * @summary Updates the attributes associated with a specified secret in a given key vault.
     * @param secretName The name of the secret.
     * @param secretVersion The version of the secret.
     * @param [options] The optional parameters
     */
    updateSecretProperties(secretName: string, secretVersion: string, options?: UpdateSecretPropertiesOptions): Promise<SecretProperties>;
    /**
     * The getSecret method is applicable to any secret stored in Azure Key Vault. This operation requires
     * the secrets/get permission.
     *
     * Example usage:
     * ```ts
     * let client = new SecretClient(url, credentials);
     * let secret = await client.getSecret("MySecretName");
     * ```
     * @summary Get a specified secret from a given key vault.
     * @param secretName The name of the secret.
     * @param [options] The optional parameters
     */
    getSecret(secretName: string, options?: GetSecretOptions): Promise<KeyVaultSecret>;
    /**
     * The getDeletedSecret method returns the specified deleted secret along with its attributes.
     * This operation requires the secrets/get permission.
     *
     * Example usage:
     * ```ts
     * let client = new SecretClient(url, credentials);
     * await client.getDeletedSecret("MyDeletedSecret");
     * ```
     * @summary Gets the specified deleted secret.
     * @param secretName The name of the secret.
     * @param [options] The optional parameters
     */
    getDeletedSecret(secretName: string, options?: GetDeletedSecretOptions): Promise<DeletedSecret>;
    /**
     * The purge deleted secret operation removes the secret permanently, without the possibility of
     * recovery. This operation can only be enabled on a soft-delete enabled vault. This operation
     * requires the secrets/purge permission.
     *
     * Example usage:
     * ```ts
     * const client = new SecretClient(url, credentials);
     * const deletePoller = await client.beginDeleteSecret("MySecretName");
     * await deletePoller.pollUntilDone();
     * await client.purgeDeletedSecret("MySecretName");
     * ```
     * @summary Permanently deletes the specified secret.
     * @param secretName The name of the secret.
     * @param [options] The optional parameters
     */
    purgeDeletedSecret(secretName: string, options?: PurgeDeletedSecretOptions): Promise<void>;
    /**
     * Recovers the deleted secret in the specified vault.
     * This function returns a Long Running Operation poller that allows you to wait indifinetly until the secret is recovered.
     *
     * This operation requires the secrets/recover permission.
     *
     * Example usage:
     * ```ts
     * const client = new SecretClient(url, credentials);
     * await client.setSecret("MySecretName", "ABC123");
     *
     * const deletePoller = await client.beginDeleteSecret("MySecretName");
     * await deletePoller.pollUntilDone();
     *
     * const recoverPoller = await client.recoverDeletedSecret("MySecretName");
     *
     * // Serializing the poller
     * const serialized = recoverPoller.toJSON();
     *
     * // A new poller can be created with:
     * // const newPoller = await client.beginRecoverDeletedSecret("MySecretName", { resumeFrom: serialized });
     *
     * // Waiting until it's done
     * const deletedSecret = await recoverPoller.pollUntilDone();
     * console.log(deletedSecret);
     * ```
     * @summary Recovers the deleted secret to the latest version.
     * @param secretName The name of the deleted secret.
     * @param [options] The optional parameters
     */
    beginRecoverDeletedSecret(name: string, options?: SecretPollerOptions): Promise<PollerLike<PollOperationState<SecretProperties>, SecretProperties>>;
    /**
     * Requests that a backup of the specified secret be downloaded to the client. All versions of the
     * secret will be downloaded. This operation requires the secrets/backup permission.
     *
     * Example usage:
     * ```ts
     * let client = new SecretClient(url, credentials);
     * let backupResult = await client.backupSecret("MySecretName");
     * ```
     * @summary Backs up the specified secret.
     * @param secretName The name of the secret.
     * @param [options] The optional parameters
     */
    backupSecret(secretName: string, options?: BackupSecretOptions): Promise<Uint8Array | undefined>;
    /**
     * Restores a backed up secret, and all its versions, to a vault. This operation requires the
     * secrets/restore permission.
     *
     * Example usage:
     * ```ts
     * let client = new SecretClient(url, credentials);
     * let mySecretBundle = await client.backupSecret("MySecretName");
     * // ...
     * await client.restoreSecretBackup(mySecretBundle);
     * ```
     * @summary Restores a backed up secret to a vault.
     * @param secretBundleBackup The backup blob associated with a secret bundle.
     * @param [options] The optional parameters
     */
    restoreSecretBackup(secretBundleBackup: Uint8Array, options?: RestoreSecretBackupOptions): Promise<SecretProperties>;
    private deleteSecret;
    private recoverDeletedSecret;
    private listPropertiesOfSecretVersionsPage;
    private listPropertiesOfSecretVersionsAll;
    /**
     * Iterates all versions of the given secret in the vault. The full secret identifier and attributes are provided
     * in the response. No values are returned for the secrets. This operations requires the secrets/list permission.
     *
     * Example usage:
     * ```ts
     * let client = new SecretClient(url, credentials);
     * for await (const secretAttr of client.listPropertiesOfSecretVersions("MySecretName")) {
     *   const secret = await client.getSecret(secretAttr.name);
     *   console.log("secret version: ", secret);
     * }
     * ```
     * @param secretName Name of the secret to fetch versions for
     * @param [options] The optional parameters
     */
    listPropertiesOfSecretVersions(secretName: string, options?: ListOperationOptions): PagedAsyncIterableIterator<SecretProperties, SecretProperties[]>;
    private listPropertiesOfSecretsPage;
    private listPropertiesOfSecretsAll;
    /**
     * Iterates the latest version of all secrets in the vault.  The full secret identifier and attributes are provided
     * in the response. No values are returned for the secrets. This operations requires the secrets/list permission.
     *
     * Example usage:
     * ```ts
     * let client = new SecretClient(url, credentials);
     * for await (const secretAttr of client.listPropertiesOfSecrets()) {
     *   const secret = await client.getSecret(secretAttr.name);
     *   console.log("secret: ", secret);
     * }
     * ```
     * @summary List all secrets in the vault
     * @param [options] The optional parameters
     */
    listPropertiesOfSecrets(options?: ListOperationOptions): PagedAsyncIterableIterator<SecretProperties, SecretProperties[]>;
    private listDeletedSecretsPage;
    private listDeletedSecretsAll;
    /**
     * Iterates the deleted secrets in the vault.  The full secret identifier and attributes are provided
     * in the response. No values are returned for the secrets. This operations requires the secrets/list permission.
     *
     * Example usage:
     * ```ts
     * let client = new SecretClient(url, credentials);
     * for await (const secretAttr of client.listDeletedSecrets()) {
     *   const deletedSecret = await client.getSecret(secretAttr.name);
     *   console.log("deleted secret: ", deletedSecret);
     * }
     * ```
     * @summary List all secrets in the vault
     * @param [options] The optional parameters
     */
    listDeletedSecrets(options?: ListOperationOptions): PagedAsyncIterableIterator<DeletedSecret, DeletedSecret[]>;
    private getSecretFromSecretBundle;
    /**
     * Creates a span using the tracer that was set by the user
     * @param methodName The name of the method for which the span is being created.
     * @param requestOptions The options for the underlying http request.
     */
    private createSpan;
    /**
     * Returns updated HTTP options with the given span as the parent of future spans,
     * if applicable.
     * @param span The span for the current operation
     * @param options The options for the underlying http request
     */
    private setParentSpan;
}

/**
 * @interface
 * An interface representing the secret client. For internal use.
 */
declare interface SecretClientInterface {
    recoverDeletedSecret(secretName: string, options?: coreHttp.RequestOptionsBase): Promise<SecretProperties>;
    getSecret(secretName: string, options?: GetSecretOptions): Promise<KeyVaultSecret>;
    deleteSecret(secretName: string, options?: coreHttp.RequestOptionsBase): Promise<DeletedSecret>;
    getDeletedSecret(secretName: string, options?: coreHttp.RequestOptionsBase): Promise<DeletedSecret>;
}

/**
 * @interface
 * An interface representing the optional parameters that can be
 * passed to beginDeleteSecret
 */
export declare interface SecretPollerOptions extends coreHttp.RequestOptionsBase {
    /**
     * @member {number} [intervalInMs] Time between each polling
     */
    intervalInMs?: number;
    /**
     * @member {string} [resumeFrom] A serialized poller, used to resume an existing operation
     */
    resumeFrom?: string;
}

/**
 * @interface
 * An interface representing the a secret's attributes.
 */
export declare interface SecretProperties {
    /**
     * @member {string} [vaultEndpoint] The vault URI.
     */
    vaultEndpoint: string;
    /**
     * @member {string} [version] The version of key/secret/certificate. May be undefined.
     */
    version?: string;
    /**
     * @member {string} [name] The name of key/secret/certificate.
     */
    name: string;
    /**
     * @member {string} [id] The secret id.
     */
    id?: string;
    /**
     * @member {string} [contentType] The content type of the secret.
     */
    contentType?: string;
    /**
     * @member {boolean} [enabled] Determines whether the object is enabled.
     */
    enabled?: boolean;
    /**
     * @member {Date} [notBefore] Not before date in UTC.
     */
    readonly notBefore?: Date;
    /**
     * @member {Date} [expiresOn] Expiry date in UTC.
     */
    readonly expiresOn?: Date;
    /**
     * @member {{ [propertyName: string]: string }} [tags] Application specific
     * metadata in the form of key-value pairs.
     */
    tags?: {
        [propertyName: string]: string;
    };
    /**
     * @member {URL} [keyId] If this is a secret backing a KV certificate, then
     * this field specifies the corresponding key backing the KV certificate.
     * **NOTE: This property will not be serialized. It can only be populated by
     * the server.**
     */
    readonly keyId?: URL;
    /**
     * @member {boolean} [managed] True if the secret's lifetime is managed by
     * key vault. If this is a secret backing a certificate, then managed will be
     * true.
     * **NOTE: This property will not be serialized. It can only be populated by
     * the server.**
     */
    readonly managed?: boolean;
    /**
     * @member {Date} [created] Creation time in UTC.
     * **NOTE: This property will not be serialized. It can only be populated by
     * the server.**
     */
    readonly createdOn?: Date;
    /**
     * @member {Date} [updated] Last updated time in UTC.
     * **NOTE: This property will not be serialized. It can only be populated by
     * the server.**
     */
    readonly updatedOn?: Date;
    /**
     * @member {DeletionRecoveryLevel} [recoveryLevel] Reflects the deletion
     * recovery level currently in effect for keys in the current vault. If it
     * contains 'Purgeable' the key can be permanently deleted by a privileged
     * user; otherwise, only the system can purge the key, at the end of the
     * retention interval. Possible values include: 'Purgeable',
     * 'Recoverable+Purgeable', 'Recoverable',
     * 'Recoverable+ProtectedSubscription'
     * **NOTE: This property will not be serialized. It can only be populated by
     * the server.**
     */
    readonly recoveryLevel?: DeletionRecoveryLevel;
}

/**
 * @interface
 * An interface representing the optional parameters that can be passed to setSecret.
 */
export declare interface SetSecretOptions extends coreHttp.RequestOptionsBase {
    /**
     * @member {{ [propertyName: string]: string }} [tags] Application specific
     * metadata in the form of key-value pairs.
     */
    tags?: {
        [propertyName: string]: string;
    };
    /**
     * @member {string} [contentType] Type of the secret value such as a
     * password.
     */
    contentType?: string;
    /**
     * @member {boolean} [enabled] Determines whether the object is enabled.
     */
    enabled?: boolean;
    /**
     * @member {Date} [notBefore] Not before date in UTC.
     */
    readonly notBefore?: Date;
    /**
     * @member {Date} [expiresOn] Expiry date in UTC.
     */
    readonly expiresOn?: Date;
}

export declare interface TelemetryOptions {
    value: string;
}

/**
 * @interface
 * An interface representing the optional parameters that can be passed to updateSecret.
 */
export declare interface UpdateSecretPropertiesOptions extends coreHttp.RequestOptionsBase {
    /**
     * @member {string} [contentType] Type of the secret value such as a
     * password.
     */
    contentType?: string;
    /**
     * @member {boolean} [enabled] Determines whether the object is enabled.
     */
    enabled?: boolean;
    /**
     * @member {Date} [notBefore] Not before date in UTC.
     */
    readonly notBefore?: Date;
    /**
     * @member {Date} [expiresOn] Expiry date in UTC.
     */
    readonly expiresOn?: Date;
    /**
     * @member {{ [propertyName: string]: string }} [tags] Application specific
     * metadata in the form of key-value pairs.
     */
    tags?: {
        [propertyName: string]: string;
    };
}

export { }
